<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[smalldragonluo]]></title>
  <subtitle><![CDATA[不卑不亢就是亢]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://blog.smalldragonluo.com/"/>
  <updated>2016-03-20T12:55:16.000Z</updated>
  <id>http://blog.smalldragonluo.com/</id>
  
  <author>
    <name><![CDATA[smalldragonluo]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Unix-like 系统常用命令笔记]]></title>
    <link href="http://blog.smalldragonluo.com/2016/03/18/Unix-like-%E7%B3%BB%E7%BB%9F%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/"/>
    <id>http://blog.smalldragonluo.com/2016/03/18/Unix-like-系统常用命令笔记/</id>
    <published>2016-03-18T06:52:06.000Z</published>
    <updated>2016-03-20T12:55:16.000Z</updated>
    <content type="html"><![CDATA[<p>Unix-like 系统常用命令笔记</p>
]]></content>
    <summary type="html">
    <![CDATA[Unix-like 系统常用命令笔记]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.smalldragonluo.com/tags/JavaScript/"/>
    
      <category term="前端技术" scheme="http://blog.smalldragonluo.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Node.js 子进程的使用场景]]></title>
    <link href="http://blog.smalldragonluo.com/2016/03/13/Node.js-%E5%AD%90%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <id>http://blog.smalldragonluo.com/2016/03/13/Node.js-子进程的使用场景/</id>
    <published>2016-03-13T08:19:12.000Z</published>
    <updated>2016-03-20T13:11:09.000Z</updated>
    <content type="html"><![CDATA[<h3 id="简介">简介</h3><p>child_process 模块为 Node.js 提供了产生子进程的能力，本文将对其中的几种方案分别进行使用场景的讨论。</p>
<h3 id="方案">方案</h3><h4 id="spawn()">spawn()</h4><p><strong>spawn()</strong> 作为最核心的方法，提供了丰富的配置，足以应对各种场景。child_process 产生子进程的能力来源于 spawn 方法，其它方法都是基于此方法的不同实现。我们先说这个方法。</p>
<p><strong>child_process.spawn(command[, args][, options])</strong></p>
<ul>
<li><strong>command</strong> &lt;String&gt; 命令</li>
<li><strong>args</strong> &lt;Array&gt; 字符串参数</li>
<li><strong>options</strong> &lt;Object&gt; 配置项</li>
</ul>
<p>其中，<strong>command</strong> 指的是可执行文件的路径，如果可执行文件处于环境变量 <strong>&#36;PATH</strong> 指向的目录中，则目录可以省略(执行 <code>echo $PATH</code> 查看目录)。 <strong>options</strong> 中以下几个参数需要注意:</p>
<ul>
<li><strong>cwd &lt;String&gt;</strong> 工作目录, 虽然你可以通过 <code>process.chdir()</code> 改变工作目录，但仍然建议使用此参数指定，当你提供的服务需要在多个目录切换时，并发访问会造成不可预料的结果。</li>
<li><strong>stdio &lt;Array&gt; | &lt;String&gt;</strong> 指定标准输入输出与错误，其值主要有 <code>&#39;pipe&#39;</code>、 <code>&#39;ipc&#39;</code>、<code>object &lt;Stream&gt;</code>、<code>fd &lt;Number&gt;</code>、<code>&#39;inherit&#39;</code>、<code>&#39;ignore&#39;</code>。<ul>
<li>当值为 <code>&#39;pipe&#39;</code>，子进程的的 IO 将会以管道的方式传输(示例稍后给出)，否则，子进程的 IO Stream 为 <code>null</code>。</li>
<li>当值为 <code>&#39;ipc&#39;</code>，子进程与父进程之间会创建一条 IPC 管道，你可以通过 <code>send()</code> 方法与监听 <code>&#39;message&#39;</code> 事件进行消息与 fd 的传输。</li>
<li>当值为实现了 <strong>Stream</strong> 接口的对象，子进程 IO 将会与之相对应，例如传递 process.stdin。同样的，传递 File Descriptor 也会被映射为 <strong>Stream</strong> 对象。例如，使用 <code>fs.open()</code> 获取一个文件描述符，或者传递 0、1、2，这分别是当前进程的 stdin，stdout，stderr 的文件描述符。</li>
<li>当值为 <code>&#39;inherit&#39;</code>，子进程会直接使用当前进程的 IO。例如将子进程的消息打印到父进程中，或者复用父进程的输入流。<br><strong>ignore</strong> 会将子进程的 IO 指向 <code>/dev/null</code>。</li>
</ul>
</li>
</ul>
<p>例如，下载一个文件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">var</span> childProcess = <span class="built_in">require</span>(<span class="string">'child_process'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cp = childProcess.spawn(<span class="string">'/usr/bin/curl'</span>, [<span class="string">'https://img.alicdn.com/任意内容/TB1uq2BIFXXXXbFXpXXXXXXXXXX_!!0-item_pic.jpg'</span>]);</span><br><span class="line"></span><br><span class="line">cp.stdout.pipe(fs.createWriteStream(<span class="string">'/Users/username/Downloads/test.jpg'</span>));</span><br></pre></td></tr></table></figure>
<h5 id="子进程独立">子进程独立</h5><p>当你希望父进程执行结束退出后，子进程仍可以保持运行，你需要使用到 <code>process.unref()</code> 方法。<br>正常情况下，父进程需要等待子进程执行结束后才能退出，使用 <code>process.unref()</code> 方法会把子进程从父进程的 event loop 中剔除，达到独立运行的效果。<br>但这并不是完全的进程独立，如果父进程未执行结束，键入 <strong>command + C</strong> 会将子进程一并结束。因为 <strong>command + C</strong> 会对整个进程组发送 <strong>SIGINT</strong> 信号，子进程也会捕获这个信号。如需避免这种情况，可以在 <strong>options</strong> 中配置 <strong>detached</strong> 为 <code>true</code>。子进程会运行在独立的进程组与 session 中，成为 leader。从而屏蔽了 <strong>SIGINT</strong> 信号。<br>如果子进程使用了父进程的 IO，调用 <code>unref()</code> 方法会结束子进程，无法达到独立运行的效果。</p>
<p>例如</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> childProcess = <span class="built_in">require</span>(<span class="string">'child_process'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cp = childProcess.spawn(<span class="string">'/Users/smalldragonluo/somewhere/node/bin/node'</span>, [<span class="string">'./index.js'</span>], &#123;</span><br><span class="line">  stdio: <span class="string">'ignore'</span>,</span><br><span class="line">  detached: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">cp.unref();</span><br></pre></td></tr></table></figure>
<h4 id="exec()">exec()</h4><p>这个方法会产生一个 shell，和 spawn 不同的是，它关注的是执行的结果，而不是过程中的 IO 通信。因此它提供了一个默认最大值为 200 KB 的缓冲区。</p>
<p><strong>child_process.exec(command[, options][, callback])</strong></p>
<p>命令的参数与 shell 类似，使用空格分隔。这并不是一个十分安全的操作，如果使用不当，你可能会迎来一个新的人生低谷。可以想到的例子是</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 安全地删除一个文件</span><br><span class="line"> * @param dir </span><br><span class="line"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">rmFileSafely</span>(<span class="params">dir</span>)</span>&#123;</span><br><span class="line">   exec(<span class="string">'rm -rvf '</span> + dir);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>如果传入 <code>&#39;/usr /lib/nvidia-current/xorg/xorg&#39;</code>，这就酿成了一出惨剧。你可以改用通过 <strong>Array</strong> 传递参数的方案，例如 <code>execFile()</code>（后面会提到）。</p>
<p>很多人看到这段代码肯定会情难自控地放到自己电脑上跑一遍，出于人道主义，也为了避免不必要的纠纷，我不建议你这么做。</p>
<p>如果你曾经遇到 <code>Error: stdout maxBuffer exceeded.</code> 这个错误，说明当前场景并不适合使用 exec 方法。增加 maxBuffer 只是缓兵之计。</p>
<p>因为此方法产生了一个 shell，所以你可以使用 <a href="http://www.tldp.org/LDP/abs/html/io-redirection.html" target="_blank" rel="external">I/O redirection</a>，<a href="http://www.tldp.org/LDP/abs/html/globbingref.html" target="_blank" rel="external">file globbing</a> 等特性。</p>
<h4 id="execFile()">execFile()</h4><p>此方法与 exec 类似，但并不会产生一个 shell，性能上稍好。</p>
<p><strong>child_process.execFile(file[, args][, options][, callback])</strong></p>
<p>命令参数以数组的方式传递，这更加安全。</p>
<h4 id="fork()">fork()</h4><p>此方法的特点是可以直接传递模块路径，并且可以使用 <strong>execPath</strong> 指定 Node.js 的可执行文件地址，你可以很方便的切换 Node.js 版本。</p>
<p><strong>child_process.fork(modulePath[, args][, options])</strong></p>
<p>除此之外，设置 <strong>silent</strong> 为 <code>true</code> 可以使子进程不使用父进程的 IO，世界瞬间清净了，掉根针都听得见。<br>使用 <code>fork()</code> 方法会创建 IPC chanel，这是进程间通信的条件。Cluster 模块就使用此方法创建工作进程。<br>当然，你会发现，不只是 <code>fork()</code> 方法才能够指定 Node.js 的执行路径，但相比 <code>spawn()</code>, <code>fork()</code> 可能会带来更低的因创建进程带来的性能消耗。</p>
<h3 id="小结">小结</h3><p>那么，应该如何选择这几种方案呢？我们已经知道，子进程 powered by spawn，其它的方法只是不同的实现。<br>当你仅仅希望得到一条命令的执行结果，并且能够预料到结果规模时，你应该使用 <code>exec()</code>，就是那么轻松，就是那么简单。<br>如果场景与 <code>exec()</code> 类似, 并且命令参数由用户指定，那么 <code>execFile()</code> 是个不错的选择。这带来了更少的安全问题，类似 XSS 这种头疼的概念将一去不复返，性能也会更优秀。<br>如果你希望自由切换 Node.js 版本, 并且希望执行的是一个存在的模块，并拥有与进程通信的能力，那你还在等什么？赶紧用 <code>fork()</code> 吧。<br>如果你仍然无法得到满足，那你只能选择 <code>spawn（）</code> 了。</p>
<h3 id="More">More</h3><ul>
<li>除了上述几个方法外，还有对应的同步版本，如 <code>spawnSync()</code>、<code>execSync()</code>、<code>execFileSync()</code>，这里就不再讨论。同步版本提供了更佳的编程体验，敲击键盘如丝般顺滑，让人欲仙欲死。如果你没有 IO 阻塞的顾虑，推荐使用同步版本。</li>
<li>如果你开启了大量的子进程，机器可能会变得十分缓慢，这种现象是正常的，一般宕机都会有这种前兆。每个子进程的创建都会消耗大约 15 MB 的内存空间（tested on my OSX x64），因此，请慎重使用子进程。</li>
<li>跨平台需要注意的地方，这里并没有提到，例如 <code>spawn()</code> 方法需要指定可执行文件为 <code>&#39;cmd&#39;</code> 等。</li>
</ul>
<h3 id="参考">参考</h3><p><a href="https://nodejs.org/api/child_process.html" target="_blank" rel="external">https://nodejs.org/api/child_process.html</a><br><a href="https://www.win.tue.nl/~aeb/linux/lk/lk-10.html" target="_blank" rel="external">https://www.win.tue.nl/~aeb/linux/lk/lk-10.html</a></p>
]]></content>
    <summary type="html">
    <![CDATA[child_process 模块为 Node.js 提供了产生子进程的能力，本文将对其中的几种方案分别进行使用场景的讨论。]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.smalldragonluo.com/tags/JavaScript/"/>
    
      <category term="Node.js" scheme="http://blog.smalldragonluo.com/tags/Node-js/"/>
    
      <category term="前端技术" scheme="http://blog.smalldragonluo.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[「淘宝技术部」内推开始啦~]]></title>
    <link href="http://blog.smalldragonluo.com/2016/03/04/%E3%80%8C%E6%B7%98%E5%AE%9D%E6%8A%80%E6%9C%AF%E9%83%A8%E3%80%8D%E5%86%85%E6%8E%A8%E5%BC%80%E5%A7%8B%E5%95%A6/"/>
    <id>http://blog.smalldragonluo.com/2016/03/04/「淘宝技术部」内推开始啦/</id>
    <published>2016-03-04T03:27:12.000Z</published>
    <updated>2016-03-04T03:51:41.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>贴吧发帖被系统删，只能在这里发了…</p>
</blockquote>
<p><strong>阿里巴巴集团2016年春季实习生招聘-内部推荐火热启动！</strong></p>
<p><img src="http://ww3.sinaimg.cn/large/a26409a6gw1eupjy5o032j20fk07840e.jpg" alt="招聘海报"></p>
<p>淘宝技术部，是支撑淘宝业务发展的核心研发团队，负责各个细分行业市场、跨境电商、商家运营、生活服务、互动内容及社区等全业务线，以及交易基础平台、内容平台、会员平台、招商平台、营销平台、建站系统等核心业务平台的开发/前端/测试等工作，支撑淘宝双十一/双十二大促的稳定性和高并发业务场景，服务全球几亿用户的吃穿住行消费需求。</p>
<p>阿里巴巴集团2016实习生招聘官网：<a href="https://campus.alibaba.com/trainNotice.htm" target="_blank" rel="external">https://campus.alibaba.com/trainNotice.htm</a></p>
<h4 id="内推岗位">内推岗位</h4><p>研发工程师JAVA（杭州/北京）、客户端开发工程师（杭州）、前端开发工程师（杭州/北京）、测试工程师（杭州）、算法工程师（杭州）<br>岗位详情：<a href="https://campus.alibaba.com/traineePositionList.htm" target="_blank" rel="external">https://campus.alibaba.com/traineePositionList.htm</a><br>（注：此处只包含淘宝技术部岗位）</p>
<h4 id="内推对象">内推对象</h4><p>2017年1月1日及以后毕业的同学（通常为2017届及以后毕业的同学）</p>
<h4 id="内推时间">内推时间</h4><p>即日起至2016年3月31日</p>
<h4 id="联系方式">联系方式</h4><p>感兴趣的同学，请把简历发送至我的邮箱（xiaolong.lxl@alibaba-inc.com）QQ：594506262</p>
<h4 id="tips">tips</h4><p>内推可以免笔试直接面试，即便未通过，也可以参加正常校招</p>
]]></content>
    <summary type="html">
    <![CDATA[这是一个广告贴]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[一个简单的 JS 模板引擎]]></title>
    <link href="http://blog.smalldragonluo.com/2016/02/05/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84-JS-%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/"/>
    <id>http://blog.smalldragonluo.com/2016/02/05/一个简单的-JS-模板引擎/</id>
    <published>2016-02-05T02:19:25.000Z</published>
    <updated>2016-03-07T11:03:03.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>快过年了，需求不饱和，有时间写写博客。</p>
</blockquote>
<h3 id="What’s_this?">What’s this?</h3><p>这是一个清爽的 JavaScript 语法模板引擎，使用自带的 JavaScript 解释器，无中间语法，压缩后仅 0.45 kb。</p>
<p>思路：</p>
<ul>
<li>拆分语句与表达式（一次处理，提高性能）</li>
<li>拼装 compiler 函数</li>
<li>转义 html 中的单引号与转义符，保留函数与 html 格式</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Tpl</span>(<span class="params">tpl</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 关于传递 RegExp https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/split</span></span><br><span class="line">  <span class="keyword">var</span> snippet = tpl.split(<span class="regexp">/(?=&lt;%)|(%&gt;)/</span>);</span><br><span class="line">  <span class="keyword">var</span> mCode = [</span><br><span class="line">    <span class="string">'var _tplSnippet = [];'</span>,</span><br><span class="line">    <span class="string">'with(_tplData) &#123;'</span></span><br><span class="line">  ];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; snippet.length; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> snippet[i] !== <span class="string">'undefined'</span> &amp;&amp; snippet[i] !== <span class="string">'%&gt;'</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (snippet[i].substring(<span class="number">0</span>, <span class="number">2</span>) === <span class="string">'&lt;%'</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果是表达式</span></span><br><span class="line">        <span class="keyword">if</span> (snippet[i].charAt(<span class="number">2</span>) === <span class="string">'='</span>) &#123;</span><br><span class="line">          mCode.push(snippet[i].replace(<span class="regexp">/&lt;%=((\s|.)+)/g</span>, <span class="string">'_tplSnippet.push($1);'</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 如果是语句</span></span><br><span class="line">          mCode.push(snippet[i].replace(<span class="regexp">/&lt;%((\s|.)+)/g</span>, <span class="string">'$1'</span>));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果是 html</span></span><br><span class="line">        mCode.push(<span class="string">'_tplSnippet.push(\''</span> + snippet[i].replace(<span class="regexp">/\\/g</span>, <span class="string">'\\\\'</span>).replace(<span class="regexp">/'/g</span>, <span class="string">'\\\''</span>).replace(<span class="regexp">/\n/g</span>, <span class="string">'\\n'</span>) + <span class="string">'\');'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  mCode.push(<span class="string">'&#125;'</span>, <span class="string">'return _tplSnippet.join(\'\');'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'_tplData'</span>, mCode.join(<span class="string">''</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ShowCase">ShowCase</h3><p>你可以在这里编辑模板与数据</p>
<textarea class="J_Tpl custom-tpl"></textarea>

<textarea class="J_Data custom-data"></textarea>

<button class="J_Compile custom-btn">运行</button>

<pre class="J_Result custom-result"></pre>

<h3 id="性能">性能</h3><p>我做了一些测试，结果证明，即便是模板中包含大量复杂的业务逻辑，构建渲染函数过程的性能消耗也是微乎其微的，查看 TimeLine 时间大概在 1 毫秒左右。<br>因此可以见得，团队使用离线编译原生 JavaScript 语法的模板，主要是为了自动化、模块化以及安全考虑，而不是性能。</p>
<style>
  .custom-tpl, .custom-data {
    width: 100%;
    height: 310px;
    outline: none;
    resize: vertical;
    padding: 4px 8px;
    border-radius: 7px;
    border: 1px solid #DDD;
  }
  .custom-btn {
    outline: none;
    display: inline-block;
    padding: 3px 20px 3px;
    line-height: 30px;
    color: #444;
    font-size: 13px;
    background: white;
    border: 1px solid #ddd;
  }
</style>

<script class="J_TplStore" type="text/html">
  <ul>
   <% for(var i = 0; i < data.length; i++) { %>
     <li>
     <% if(i === 1) { %>
     <i> * </i>
     <% } %>
     <%= data[i] %>
     </li>
   <% } %>
  </ul>
</script>

<script class="J_DataStore" type="text/html">
  {
    "data": [1, 2, 3]
  }
</script>

<script>
(function tmp(){
  if(window.$) {
    function Tpl(tpl) {
          // 关于传递 RegExp https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/split
          var snippet = tpl.split(/(?=<%)|(%>)/);
          var mCode = [
            'var _tplSnippet = [];',
            'with(_tplData) {'
          ];

          for (var i = 0; i < snippet.length; ++i) {
            if (typeof snippet[i] !== 'undefined' && snippet[i] !== '%>') {
              if (snippet[i].substring(0, 2) === '<%') {
                // 如果是表达式
                if (snippet[i].charAt(2) === '=') {
                  mCode.push(snippet[i].replace(/<%=((\s|.)+)/g, '_tplSnippet.push($1);'));
                } else {
                  // 如果是语句
                  mCode.push(snippet[i].replace(/<%((\s|.)+)/g, '$1'));
                }
              } else {
                // 如果是 html
                mCode.push('_tplSnippet.push(\'' + snippet[i].replace(/\\/g, '\\\\').replace(/'/g, '\\\'').replace(/\n/g, '\\n') + '\');');
              }
            }
          }

          mCode.push('}', 'return _tplSnippet.join(\'\');');

          return new Function('_tplData', mCode.join(''));
        }

        $('.J_Tpl').val($('.J_TplStore').html());
        $('.J_Data').val($('.J_DataStore').html());

        $('.J_Compile').on('click', function(){
          if(!JSON) {
            $('.J_Result').text('你的浏览器没有 JSON 对象，请切换浏览器再试');
            return;
          }

          var compiler, data, t, cTime, rTime;

          try {
            t = new Date().getTime();
            compiler = Tpl($('.J_Tpl').val());
            cTime = new Date().getTime() - t;
          } catch(e) {
            $('.J_Result').text('模板格式错误\n' + e.stack);
            return;
          }

          try {
            data = JSON.parse($('.J_Data').val());
          } catch(e) {
            $('.J_Result').text('数据格式错误\n' + e.stack);
            return;
          }

          try {
            t = new Date().getTime();
            var html = compiler(data);
            rTime = new Date().getTime() - t;
            $('.J_Result').text('<!-- 创建渲染函数用时：' + cTime + ' ms, 渲染用时：' + rTime + ' ms -->\n' + html);
          } catch(e) {
            $('.J_Result').text('渲染错误\n' + e.stack);
            return;
          }
        }).trigger('click');
  } else {
    setTimeout(function() {
      tmp();    
    }, 16.7);
  }
})();
</script>
]]></content>
    <summary type="html">
    <![CDATA[本文讲述了如何用简单的代码实现一个 JavaScript 语法模板引擎]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.smalldragonluo.com/tags/JavaScript/"/>
    
      <category term="模板引擎" scheme="http://blog.smalldragonluo.com/tags/%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/"/>
    
      <category term="正则表达式" scheme="http://blog.smalldragonluo.com/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
      <category term="前端技术" scheme="http://blog.smalldragonluo.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[regeneratorRuntime is not defined]]></title>
    <link href="http://blog.smalldragonluo.com/2016/01/25/regeneratorRuntime-is-not-defined/"/>
    <id>http://blog.smalldragonluo.com/2016/01/25/regeneratorRuntime-is-not-defined/</id>
    <published>2016-01-25T14:09:02.000Z</published>
    <updated>2016-02-06T06:00:35.000Z</updated>
    <content type="html"><![CDATA[<h4 id="起因">起因</h4><p>最近在开发团队自动化工具：一个基于 Node.js 的本地 SDK，和一个配套 web UI。其实本来想一个 jQuery 解决问题，同事说，用 React，大家都用这个，都说好。我说，那咱们还等什么？<br>就这样最终选择了 React.js，然后理所当然地加上了 React Router，Redux，Webpack，ES6。为了和前端保持一致，服务端也跟着使用了 ES6，这是事件的起因。</p>
<p>在 OS X 上整个开发过程比较顺利，但由于外包同学需要使用 windows，所以我需要做兼容测试。当某一天我把 SDK 放到 windows 上运行的时候卧槽它居然！！你猜怎么着？？</p>
<p>居然跑不起来。跑起来我也就不用写了。</p>
<p>根据 stack 信息，一开始以为是 Babel 的问题，最后经过仔细排查，发现是 SDK 依赖的宿主环境，而这个环境我没办法修改，因此我只能另寻出路。</p>
<p>没法使用 babel/register，那就只能将 ES6 编译成 ES5，然后 polyfill 一下。</p>
<p>我使用的 Babel 版本为 5.8.3，默认提供转换所有已经支持的最新 ES 特性，6.x 需要手动安装需要使用的特性或使用预置集（preset）。目前提供有 6 个预置集，分别是</p>
<ul>
<li>es2015</li>
<li>stage-0</li>
<li>stage-1</li>
<li>stage-2</li>
<li>stage-3</li>
<li>react</li>
</ul>
<p>我选择了 es2015，包含丰富的插件，支持包括 arrow function，Generator function，以及 Node 4.x 目前并不支持的 Module import。</p>
<h4 id="经过">经过</h4><p>使用官方指定的 gulp-babel 编译后提示</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReferenceError: regeneratorRuntime is not defined.</span><br></pre></td></tr></table></figure>
<p>我思索良久，仍不解心头之惑 —— 为什么，为什么他们要把一个变量定义的这么长？</p>
<p>凭着我的聪明才智，我翻看 build 之后的文件，发现每个头部都添加了 <code>&#39;use strict;&#39;</code>，难道，这就是祸乱的根源？</p>
<p>通过 Google 之，发现这个 <a href="https://phabricator.babeljs.io/T6676" target="_blank" rel="external">issue</a> 里有人遇到同样的问题。由于 es2015 已经自带了 transform-regenerator，所以我猜测由于严格模式导致 <code>regeneratorRuntime</code> 这个全局变量声明失败，我于是注释掉了</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node_modules/babel-preset-es2015/node_modules/babel-plugin-transform-es2015-modules-commonjs/lib/index.js</span><br></pre></td></tr></table></figure>
<p>第 130 行的 </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inherits: <span class="built_in">require</span>(<span class="string">"babel-plugin-transform-strict-mode"</span>)</span><br></pre></td></tr></table></figure>
<p>运行成功！</p>
<p>也可以在需要使用 generator 的代码中引入 <code>babel-polyfill</code>，但这在 Babel 5 中是不必要的，不够整洁。</p>
<p>如果你不想转换 generator 函数，可以注释掉 <code>babel-plugin-transform-regenerator</code>。</p>
]]></content>
    <summary type="html">
    <![CDATA[最近在开发团队自动化工具：一个基于 Node.js 的本地 SDK，和一个配套 web UI。其实本来想一个 jQuery 解决问题，同事说，用 React，大家都用这个，都说好。我说，那咱们还等什么？]]>
    
    </summary>
    
      <category term="Babel" scheme="http://blog.smalldragonluo.com/tags/Babel/"/>
    
      <category term="Gulp" scheme="http://blog.smalldragonluo.com/tags/Gulp/"/>
    
      <category term="JavaScript" scheme="http://blog.smalldragonluo.com/tags/JavaScript/"/>
    
      <category term="前端技术" scheme="http://blog.smalldragonluo.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[浅析语法分析树]]></title>
    <link href="http://blog.smalldragonluo.com/2015/12/06/%E6%B5%85%E6%9E%90%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E6%A0%91/"/>
    <id>http://blog.smalldragonluo.com/2015/12/06/浅析语法分析树/</id>
    <published>2015-12-06T14:53:42.000Z</published>
    <updated>2015-12-26T15:08:52.000Z</updated>
    <content type="html"><![CDATA[<h4 id="语法分析树">语法分析树</h4><p>语法分析树，一般称它为具体语法树，相应的语法称之为该语言的具体语法。语法分析树和产生式相对应，用于展现从文法开始符号推导符号串的过程。<br>语法分析树是一种树形结构，是语法制导翻译中不可缺少的因素。</p>
<h4 id="节点形式">节点形式</h4><ul>
<li>树的根节点是文法的开始符号</li>
<li>叶子节点为终结符号或者 ∈</li>
<li>内部节点的标号为非终结符号</li>
</ul>
<h4 id="图示">图示</h4><p>以下列产生式为例</p>
<ul>
<li>A -&gt; + A A</li>
<li>A -&gt; - A A</li>
<li>A -&gt; digit</li>
</ul>
<p>+ 1 - 2 3 对应的语法分析树是</p>
<p><img src="/assets/st.jpg" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="语法分析树">语法分析树</h4><p>语法分析树，一般称它为具体语法树，相应的语法称之为该语言的具体语法。语法分析树和产生式相对应，用于展现从文法开始符号推导符号串的过程。<br>语法分析树是一种树形结构，是语法制导翻译中不可缺少的因素。</p>
<h4 id=]]>
    </summary>
    
      <category term="编译器" scheme="http://blog.smalldragonluo.com/tags/%E7%BC%96%E8%AF%91%E5%99%A8/"/>
    
      <category term="语法分析树" scheme="http://blog.smalldragonluo.com/tags/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E6%A0%91/"/>
    
      <category term="前端技术" scheme="http://blog.smalldragonluo.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
      <category term="编译" scheme="http://blog.smalldragonluo.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/%E7%BC%96%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[浅析上下文无关文法]]></title>
    <link href="http://blog.smalldragonluo.com/2015/12/06/%E6%B5%85%E6%9E%90%E4%B8%8A%E4%B8%8B%E6%96%87%E6%97%A0%E5%85%B3%E6%96%87%E6%B3%95/"/>
    <id>http://blog.smalldragonluo.com/2015/12/06/浅析上下文无关文法/</id>
    <published>2015-12-06T14:07:51.000Z</published>
    <updated>2015-12-06T14:52:12.000Z</updated>
    <content type="html"><![CDATA[<p>在编译器的分析部分，需要使用一种表示方法用于描述程序语言的语法，上下文无关文法是表示方法中的一种。</p>
<h4 id="文法定义">文法定义</h4><h5 id="组成要素">组成要素</h5><p>一个上下文无关文法由四个元素组成：</p>
<ul>
<li>一个终结符号集合，终结符号是文法中最基本的符号，可以将其理解为最小的符号，有时也称为词法单元</li>
<li>一个非终结符号集合，又称「语法变量」，是终结符号的集合</li>
<li>一个产生式集合，产生式用来表示某种构造的书写形式，由产生式头，箭头，产生式体组成，稍后会有详细介绍</li>
<li>一个开始符号，此符号为非终结符号</li>
</ul>
<h5 id="产生式">产生式</h5><p>以 JAVA 语句为例子，一个 if-else 的语句一般是以下形式：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="type">expr</span>) <span class="type">stmt</span> <span class="keyword">else</span> <span class="type">stmt</span></span><br></pre></td></tr></table></figure>
<p>上述语句可以用一个产生式表示为：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">stmt </span>-&gt; <span class="preprocessor">if</span> (expr) <span class="keyword">stmt </span><span class="preprocessor">else</span> <span class="keyword">stmt</span></span><br></pre></td></tr></table></figure>
<p>这是一个语句的描述，其中 if，else 称为终结符号，可以由一个词法单元表示。expr，stmt 属于非终结符号，因为其可以由另一个产生式表示。</p>
<p>举个简单的例子，接下来通过上下文无关文法描述一个简单的语法–乘除过程 p：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p     -&gt; p * digit</span><br><span class="line">p     -&gt; p / digit</span><br><span class="line">p     -&gt; digit</span><br><span class="line">digit -&gt; <span class="number">0</span>|<span class="number">1</span>|<span class="number">2</span>|<span class="number">3</span>|<span class="number">4</span>|<span class="number">5</span>|<span class="number">6</span>|<span class="number">7</span>|<span class="number">8</span>|<span class="number">9</span></span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[在编译器的分析部分，需要使用一种表示方法用于描述程序语言的语法，上下文无关文法是表示方法中的一种。]]>
    
    </summary>
    
      <category term="上下文无关文法" scheme="http://blog.smalldragonluo.com/tags/%E4%B8%8A%E4%B8%8B%E6%96%87%E6%97%A0%E5%85%B3%E6%96%87%E6%B3%95/"/>
    
      <category term="编译器" scheme="http://blog.smalldragonluo.com/tags/%E7%BC%96%E8%AF%91%E5%99%A8/"/>
    
      <category term="前端技术" scheme="http://blog.smalldragonluo.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
      <category term="编译" scheme="http://blog.smalldragonluo.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/%E7%BC%96%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Designed By smalldragonluo]]></title>
    <link href="http://blog.smalldragonluo.com/2015/12/05/Designed-By-smalldragonluo/"/>
    <id>http://blog.smalldragonluo.com/2015/12/05/Designed-By-smalldragonluo/</id>
    <published>2015-12-05T08:24:29.000Z</published>
    <updated>2015-12-05T10:59:55.000Z</updated>
    <content type="html"><![CDATA[<p>这是一款我在大学设计的 APP UI，现在看来，还有许多细节不够好，但毕竟是自己的… 儿子？噢，这个比喻不太好，我其实是想表达：虽然设计平庸，但好歹是一点一滴创造出来的，我应该给他留下回忆。</p>
<p>一开始想这样</p>
<p><img src="/assets/app.jpg" alt=""></p>
<p>后来改成了</p>
<p><img src="/assets/index.png" alt=""></p>
<p>再后来改成了</p>
<p><img src="/assets/index2.png" alt=""></p>
<p>菜单</p>
<p><img src="/assets/menu.png" alt=""></p>
<p>订单列表</p>
<p><img src="/assets/order.png" alt=""></p>
<p>订单详情</p>
<p><img src="/assets/order_detail.png" alt=""></p>
<p>个人主页</p>
<p><img src="/assets/personal.png" alt=""></p>
<p>IM</p>
<p><img src="/assets/talk.png" alt=""></p>
<p><img src="/assets/confirm.png" alt=""></p>
<p><img src="/assets/map.png" alt=""></p>
<p><img src="/assets/opt.png" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[这是一款我在大学设计的 APP UI，现在看来，还有许多细节不够好，但毕竟是自己的... 儿子？噢，这个比喻不太好，我其实是想表达：虽然设计平庸，但好歹是一点一滴创造出来的，我应该给他留下回忆。]]>
    
    </summary>
    
      <category term="UI设计" scheme="http://blog.smalldragonluo.com/tags/UI%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="UI设计" scheme="http://blog.smalldragonluo.com/categories/UI%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一个编译器的主要流程]]></title>
    <link href="http://blog.smalldragonluo.com/2015/12/03/%E4%B8%80%E4%B8%AA%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E4%B8%BB%E8%A6%81%E6%B5%81%E7%A8%8B/"/>
    <id>http://blog.smalldragonluo.com/2015/12/03/一个编译器的主要流程/</id>
    <published>2015-12-03T09:51:29.000Z</published>
    <updated>2015-12-04T02:00:33.000Z</updated>
    <content type="html"><![CDATA[<h4 id="编译器简介">编译器简介</h4><p>编译器的作用是将源程序翻译成另一种语言，例如，将 JAVA 代码编译为二进制 .class 文件以跨平台运行，将 JSP 文件编译成 Servlet 代码，将 HTML 模板编译为 JavaScript 代码，这和解释型语言（几乎所有的脚本语言）有所不同，后者是在运行时直接解释运行。<br>编译器的设计目标是：</p>
<ul>
<li><p>极致的性能优化，这通常是最具挑战的目标</p>
</li>
<li><p>高效编译，即编译应该控制在合理的时间内</p>
</li>
<li><p>正确的优化，即不能改变源程序的含义</p>
</li>
</ul>
<p>一个语言的编译器分为两个部分，一个是分析部分，一个是综合部分，我们称分析部分为编译器的前端，综合部分为编译器的后端。分析部分包括：</p>
<h4 id="分析部分">分析部分</h4><ul>
<li><p>词法分析<br>这一步将源程序组织成词素序列，并输出词法单元，词法单元类似 &lt;id, index&gt;，index 为符号表对应的索引。</p>
</li>
<li><p>语法分析<br>根据词法单元生成可表示语法结构的中间形式，例如语法树，这个步骤会帮助编译器在接下来的过程中对源程序进行分析。</p>
</li>
<li><p>语义分析<br>这一步骤会做类型检查，如果出现类型错误，编译器会在这个阶段发现。如果程序语言支持自动类型转换，会将某些数据类型做转换。这一阶段会分析更加细致的语义信息，并补充符号表或语法树。</p>
</li>
</ul>
<h4 id="综合部分">综合部分</h4><p>这一部分会做很多更加复杂的工作，包括中间代码生成（生成中间表示会存在整个编译周期）和优化工作。随着计算机架构的不断更新，多核 CPU 的出现，如何使计算机指令执行效率得到提高，充分利用机器性能成为编译器的目标与挑战。<br>这一阶段会生成易于生成，易于翻译成目标机器代码的中间代码，例如『三地址代码』：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="setting">t1 = <span class="value">inttofloat(<span class="number">60</span>)</span></span></span><br><span class="line"><span class="setting">t2 = <span class="value">id3 * t1</span></span></span><br><span class="line"><span class="setting">t3 = <span class="value">id2 + t2</span></span></span><br><span class="line"><span class="setting">id1 = <span class="value">t3</span></span></span><br></pre></td></tr></table></figure>
<p>并优化，生成目标语言，如汇编语言。然后由汇编器生成目标机器代码。</p>
<p>通常，在分析部分开始之前，还会有预处理器，所做的工作是将『宏』转换到代码语句中。</p>
]]></content>
    <summary type="html">
    <![CDATA[编译器的作用是将源程序翻译成另一种语言，例如，将 JAVA 代码编译为二进制 .class 文件以跨平台运行，将 JSP 文件编译成 Servlet 代码，将 HTML 模板编译为 JavaScript 代码，这和解释型语言（几乎所有的脚本语言）有所不同，后者是在运行时直接解释运行。]]>
    
    </summary>
    
      <category term="编译器" scheme="http://blog.smalldragonluo.com/tags/%E7%BC%96%E8%AF%91%E5%99%A8/"/>
    
      <category term="前端技术" scheme="http://blog.smalldragonluo.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
      <category term="编译" scheme="http://blog.smalldragonluo.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/%E7%BC%96%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Process-Killer，an Alfred Workflow]]></title>
    <link href="http://blog.smalldragonluo.com/2015/11/29/Process-Killer-%E4%B8%80%E4%B8%AA-Alfred-Workflow/"/>
    <id>http://blog.smalldragonluo.com/2015/11/29/Process-Killer-一个-Alfred-Workflow/</id>
    <published>2015-11-29T12:39:00.000Z</published>
    <updated>2015-12-06T14:19:03.000Z</updated>
    <content type="html"><![CDATA[<p><a href="https://www.alfredapp.com/" target="_blank" rel="external">Alfred</a> 是一个 Mac 上的效率工具，官网对其的定义是：</p>
<blockquote>
<p>Alfred is an award-winning app for Mac OS X which boosts your efficiency with hotkeys and keywords. Search your Mac and the web effortlessly, and control your Mac using customised actions with the Powerpack.<br>Alfred 是一个 Mac 上的获奖应用，可以通过快捷键和关键字提高你的效率，除此之外，还可以高效地搜索本地和网络，通过 Powerpack 自定义动作控制你的电脑。</p>
</blockquote>
<h4 id="什么是_Process-Killer？">什么是 Process-Killer？</h4><p>回到正题，Process-Killer 是一个我编写的 Alfred 插件（其准确的定义应该是 <strong>customised actions</strong>），功能是根据你输入的进程名称或者 PID 或者端口号结束对应进程。</p>
<p>例如</p>
<p><img src="https://camo.githubusercontent.com/a2e1ceee9d2199adcca3a9f3118da1682d8cc4a7/68747470733a2f2f696d672e616c6963646e2e636f6d2f7470732f5442314b5545414b465858585861735870585858585858585858582d3538342d3232332e6a7067" alt=""></p>
<p>如你所见，输入关键字 kill，会进入匹配模式，你可以输入进程名称，PID 或者 -i 端口号，列表会显输出对应的进程，选中并确定，一个进程就将殒命，消失于宇宙的浩瀚之中（我决定以后给他加上一声惨叫，当然这是开玩笑的）。<br>你可能注意到，每个 item 的下方会显示此进程运行的参数，这对于运行多个相同的命令来说是很有帮助的。例如你打开了多个 Node.js 进程，通过这个插件可以很方便地进行区分。</p>
<h4 id="Install">Install</h4><p>如何安装呢？</p>
<ol>
<li>首先查看 <a href="https://github.com/smalldragonluo/process-killer" target="_blank" rel="external">Process-Killer</a> 仓库，下载 <strong>Process Killer.alfredworkflow</strong> 文件</li>
<li>打开 Alfred 面板，点设置，进入 Workflow，将 <strong>Process Killer.alfredworkflow</strong> 拖入左侧列表，至此，安装完成，就是这么轻松，就是这么简单。</li>
</ol>
<h4 id="工作原理">工作原理</h4><p>这个插件使用了 Node.js 作为开发语言，具体工作流程打开 Alfred 面板可以看到：</p>
<p><img src="/assets/C6671052-55E6-4EEA-A5EE-FCD9C8D93E17.png" alt=""></p>
<p>看到这里你肯定会惊讶：『这个图标真他妈好看』。真不好意思，这是我画的，你可以在其他产品中使用这枚图标，这是免费的。</p>
<h5 id="内容过滤">内容过滤</h5><p>插件的入口是一个 Script Filter，顾名思义，是一个脚本过滤器，用于生成可以显示在面板的内容，出此之外还有 keyword，File Filter 等。</p>
<p>首先，Script Filter 通过 shell 调用了 Node.js 服务</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/bin/<span class="keyword">node</span><span class="identifier"> </span><span class="title">&lt;&lt;-'CODE</span>'</span><br><span class="line">require(<span class="string">"./processFilter"</span>)(<span class="string">"&#123;query&#125;"</span>);</span><br><span class="line">CODE</span><br></pre></td></tr></table></figure>
<p>其中，<code>query</code> 是面板传递的参数，这一步的目地是要通过 Node.js 生成可供面板显示的内容数据，输出格式为 XML，这里我使用了 <a href="http://npm.taobao.org/package/xtpl" target="_blank" rel="external">xtpl</a> 来输出，XML 格式大家看代码就知道意思了。<br>我还是提一下吧，我并不是为了凑字数。一个简单的 XML 格式是这样的：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">items</span>&gt;</span></span><br><span class="line">  &#123;&#123;#each(items)&#125;&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="title">item</span> <span class="attribute">uid</span>=<span class="value">"&#123;&#123;name&#125;&#125;"</span> <span class="attribute">arg</span>=<span class="value">"&#123;&#123;pid&#125;&#125;"</span> <span class="attribute">valid</span>=<span class="value">"yes"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">title</span>&gt;</span>&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="title">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">subtitle</span>&gt;</span>&#123;&#123;args&#125;&#125;<span class="tag">&lt;/<span class="title">subtitle</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">icon</span> &#123;&#123;#<span class="attribute">if</span>(<span class="attribute">isApp</span>)&#125;&#125;<span class="attribute">type</span>=<span class="value">"fileicon"</span><span class="value">&#123;&#123;</span>/<span class="attribute">if</span>&#125;&#125;&gt;</span>&#123;&#123;icon&#125;&#125;<span class="tag">&lt;/<span class="title">icon</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">item</span>&gt;</span></span><br><span class="line">  &#123;&#123;/each&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="title">items</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>其中，uid 是用来标记 item 的唯一属性，选择次数越多，会越将其靠前显示；arg 是传递到下一步的参数；valid 代表可以选定，你可以输出一个不可选定的 item 用来提示用户信息。<br><code>type=&quot;fileicon&quot;</code> 说明这是一个应用，可以直接使用 APP 的图标，value 为 APP 路径。</p>
<p>如何抽出进程的 command 与 args 是个问题，因为 shell 输出的字段以空格分割，而 command 本身也包含空格，因此我使用 child_process 执行了两次 ps 命令，分别取出 command 与 args，并将 args 做为 map 通过 PID 查询。  </p>
<h5 id="执行动作">执行动作</h5><p>Run Script 步骤会接受某个 item 的参数 arg，这个 item 是面板选定的元素。接下来执行另一段代码：</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/bin/<span class="keyword">node</span><span class="identifier"> </span><span class="title">&lt;&lt;-'CODE</span>'</span><br><span class="line">require(<span class="string">"./action"</span>)(<span class="string">"&#123;query&#125;"</span>);</span><br><span class="line">CODE</span><br></pre></td></tr></table></figure>
<p>这段代码会根据 PID，对此进程发送信号 <strong>TERM(termination signal)</strong>，5 秒后发送信号 <strong>KILL(non-ignorable kill)</strong>。</p>
<h4 id="后记">后记</h4><p>其实，我并不用太多 Alfred 的功能，大部分自带的 Spotlight 也能做，唯一使用的就只有 Workflows 了，这对开发来说还是比较方便的，希望这个插件可以帮助到你~</p>
<h4 id="参考链接">参考链接</h4><p><a href="https://developer.apple.com/library/prerelease/mac/documentation/Darwin/Reference/ManPages/man1/ps.1.html" target="_blank" rel="external">ps(1) Mac OS X Manual Page</a><br><a href="http://computers.tutsplus.com/tutorials/alfred-workflows-for-advanced-users--mac-60963" target="_blank" rel="external">Alfred Workflows for Advanced Users</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="https://www.alfredapp.com/" target="_blank" rel="external">Alfred</a> 是一个 Mac 上的效率工具，官网对其的定义是：</p>
<blockquote>
<p>Alfred is an ]]>
    </summary>
    
      <category term="Alfred" scheme="http://blog.smalldragonluo.com/tags/Alfred/"/>
    
      <category term="前端技术" scheme="http://blog.smalldragonluo.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
      <category term="实用工具" scheme="http://blog.smalldragonluo.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
</feed>
